function solution(numbers) {
   let arr = [];
    //서로다른 인덱스에 있는 두개의 수를 뽑아서 더해 -> 이중반복문을 쓸거야
    
    for(let i = 0; i<numbers.length-1; i++){
            //console.log("--")
        for(let j=i+1; j<numbers.length; j++){
            //처음에 j=1로 시작해놓고 정확하다고 철썩같이 믿음.. 위 콘솔찍고 깨달음..
           arr.push(numbers[i]+numbers[j])
        }
    }
    //배열 중복제거
    const set= new Set(arr)
    let newArr = [...set]
    
    //오름차순
    return newArr.sort((a,b)=>a-b)
    
   
}

//오름차순단계에서 sort()했는데 일부는 통과하고 일부는 아래와 같이 이상한 오름차순이 되었음
// 입력값 〉	[5, 0, 2, 7]
// 기댓값 〉	[2, 5, 7, 9, 12]
// 실행 결과 〉	실행한 결괏값 [12,2,5,7,9]이 기댓값 [2,5,7,9,12]과 다릅니다.
//테스트 케이스를 유심히 보니 12가 먼저온거봐서는 문자열처럼 다루는거같았음 따옴표가 없지만,, 타입을 확인해봄

//가설1. newArr에 있는 값이 숫자타입이 아닌가?
////console.log(typeof(newArr[0]))
    //만약 숫자가 아니었다면 이런식으로 배열의 요소를 넘버타입으로 바꿀 수 있다
    //const toNumbers = newArr => newArr.map(Number)
//응~아니야 숫자타입이야

//가설 2. 리턴을 잘못했나?
//블로그읽다보니 sort는 원본 배열을 정렬하고 리턴도 원본을 리턴한다고 하는데
//처음에 원본을 리턴하도록 구현했는데 뭐가 문제임...? 그래도 혹시 몰라서 
//맵돌려서 새 배열에 복사도해봄 응~ 그래도 아니야

//문제는 뭐다? 불완전한 오름차순을 구현하고 있었음
//sort는 정렬을 할때 요소 문자열처럼 취급한다...
//고로 온전한 오름차순을 구현하고 싶으면
//newArr.sort((a,b)=>a-b) 이렇게 구현하자...
//위 코드의 뜻은 a-b해서 음수가 나오면 a를 앞으로 보냄,,,,
